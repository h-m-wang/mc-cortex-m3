; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Source\inc -I..\..\Driver\inc -IE:\00_Workspace\0608_AG16KSDE176_DemoBoard\SCM3_DVK\Project\RVMDK\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0 -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=513 -DARMCM3 --omf_browse=.\obj\main.crf ..\..\Source\src\main.c]
                          THUMB

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;21     U32 readfromahb;
;;;22     int main(void)
000000  2001              MOVS     r0,#1
;;;23     {
;;;24       uint32_t i, j;
;;;25     	*((volatile unsigned int*)(0x40016000)) = 0x01;  //使能AHB,这个很关键，否则HREADY不能用
000002  4915              LDR      r1,|L1.88|
000004  6008              STR      r0,[r1,#0]
;;;26     	
;;;27       
;;;28     	hyhwGpio_SetOut(GPIOA,GPIO_0);
000006  2101              MOVS     r1,#1
000008  4814              LDR      r0,|L1.92|
00000a  f7fffffe          BL       hyhwGpio_SetOut
;;;29     	
;;;30     	while(1){
00000e  e021              B        |L1.84|
                  |L1.16|
;;;31     	hyhwGpio_SetHigh(GPIOA,GPIO_0);
000010  2101              MOVS     r1,#1
000012  4812              LDR      r0,|L1.92|
000014  f7fffffe          BL       hyhwGpio_SetHigh
;;;32     	for(i=10000;i>0;i--) 
000018  f2427410          MOV      r4,#0x2710
00001c  e007              B        |L1.46|
                  |L1.30|
;;;33          for(j=1000;j>0;j--)
00001e  f44f757a          MOV      r5,#0x3e8
000022  e001              B        |L1.40|
                  |L1.36|
;;;34            {
;;;35                 __NOP();
000024  bf00              NOP      
000026  1e6d              SUBS     r5,r5,#1              ;33
                  |L1.40|
000028  2d00              CMP      r5,#0                 ;33
00002a  d1fb              BNE      |L1.36|
00002c  1e64              SUBS     r4,r4,#1              ;32
                  |L1.46|
00002e  2c00              CMP      r4,#0                 ;32
000030  d1f5              BNE      |L1.30|
;;;36     				 }
;;;37     	
;;;38     	hyhwGpio_SetLow(GPIOA,GPIO_0);
000032  2101              MOVS     r1,#1
000034  4809              LDR      r0,|L1.92|
000036  f7fffffe          BL       hyhwGpio_SetLow
;;;39     	for(i=10000;i>0;i--) 
00003a  f2427410          MOV      r4,#0x2710
00003e  e007              B        |L1.80|
                  |L1.64|
;;;40          for(j=1000;j>0;j--)
000040  f44f757a          MOV      r5,#0x3e8
000044  e001              B        |L1.74|
                  |L1.70|
;;;41            {
;;;42                 __NOP();
000046  bf00              NOP      
000048  1e6d              SUBS     r5,r5,#1              ;40
                  |L1.74|
00004a  2d00              CMP      r5,#0                 ;40
00004c  d1fb              BNE      |L1.70|
00004e  1e64              SUBS     r4,r4,#1              ;39
                  |L1.80|
000050  2c00              CMP      r4,#0                 ;39
000052  d1f5              BNE      |L1.64|
                  |L1.84|
000054  e7dc              B        |L1.16|
;;;43     				 }
;;;44     	}
;;;45     	
;;;46     	//hyhwTimerA_InitTimer1(1000*1000,INTMODE_WRAPPING);
;;;47     	//NVIC_EnableIRQ(TIMERA_IRQn);
;;;48     //	ptr = (U32*)0xa0000000;
;;;49     //	for(i=0;i<1000;i++)
;;;50     //	{
;;;51     //		*ptr++ = i;
;;;52     //	}
;;;53     //	while(1);
;;;54     	
;;;55     //	/*IO 初始化*/
;;;56     //	hyhwSpiFlash_Init();
;;;57     //	gSpiFlashID = hyhwSpiFlash_ReadID();
;;;58     //	//hyhwSpiFlash_ReadUniqueID(gRdBuf);  //注明：不是所有flash支持该功能的
;;;59     //	/*说明： 在hyhw_SpiFlash.h 设置page_size和sector size
;;;60     //					 在boardsupportPackage.h中设置FLASH_CLK_DIV的时钟，保证spi的时钟不超过25Mhz
;;;61     //					 hyhwSpiFlash_WritePage中写的时候注意长度不能太大，不能跨page
;;;62     //					 hyhwSpiFlash_Write，在写之前会将sector的内容读出再回写回去。为此准备了一个sector大小的全局buffer，不需要这个函数的话，可以去掉。
;;;63     //					 hyhwSpiFlash_Read，长度不能大于1个sector。
;;;64     //	*/					
;;;65     //	hyhwSpiFlash_Read( gRdBuf,0x0, 512);
;;;66     //	for(i=0;i<1024;i++)
;;;67     //	{
;;;68     //		gRdBuf[i] = 0;
;;;69     
;;;70     //	}
;;;71     //	for(i=0;i<5*1024;i++)
;;;72     //	{
;;;73     //		gWrBuf[i] = i;
;;;74     //	}
;;;75     //	hyhwSpiFlash_EraseSector(82*FLASH_SECTOR_SIZE);
;;;76     //	hyhwSpiFlash_WritePage(gWrBuf, 82*FLASH_SECTOR_SIZE, 256);
;;;77     //	hyhwSpiFlash_Read( gRdBuf,82*FLASH_SECTOR_SIZE, 512);
;;;78     //	hyhwSpiFlash_Write( gWrBuf, 82*FLASH_SECTOR_SIZE+5,5*1024);
;;;79     //	hyhwSpiFlash_Read( gRdBuf,82*FLASH_SECTOR_SIZE, 4*1024);
;;;80     //	hyhwSpiFlash_Read( gRdBuf,82*FLASH_SECTOR_SIZE+4096, 1024);
;;;81     //	while(1);
;;;82     }
;;;83     
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      0x40016000
                  |L1.92|
                          DCD      0x40012000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  gRdBuf
                          %        5120
                  gWrBuf
                          %        5120
                  gRdAhb
                          %        400

                          AREA ||.data||, DATA, ALIGN=2

                  keytest
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  gSpiFlashID
                          DCD      0x00000000
                  ptr
                          DCD      0x00000000
                  readfromahb
                          DCD      0x00000000

                  __ARM_use_no_argv EQU 0
